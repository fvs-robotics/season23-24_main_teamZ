{"mode":"Text","textContent":"import sys\nimport vex\nfrom vex import *\nimport urandom\n\nbrain = Brain()\n\n# region config\ncontroller = Controller(PRIMARY)  # Primary controller\nmotor_left_front = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)  # Left front motor\nmotor_right_front = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)  # Right front motor\nmotor_left_back = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)  # Left back motor\nmotor_right_back = Motor(Ports.PORT19, GearSetting.RATIO_18_1, False)  # Right back motor\narm_left = Motor(Ports.PORT11, GearSetting.RATIO_36_1, False)  # Left arm motor\narm_right = Motor(Ports.PORT20, GearSetting.RATIO_36_1, False)  # Right arm motor\nintake = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)  # Intake motor\nlauncher = Motor(Ports.PORT6, GearSetting.RATIO_36_1, False)  # Launcher motor\n\n\n# end of region config\n\ndef initialize_autonomous():\n    # start the autonomous control tasks\n    _autonomous_thread = Thread(autonomous)\n    # wait for the driver control period to end\n    while (competition.is_autonomous() and competition.is_enabled()):\n        # wait 10 milliseconds before checking again\n        wait(10, MSEC)\n    # stop the autonomous control tasks\n    _autonomous_thread.stop()\n\n\ndef autonomous():\n    \"\"\"\n    Set the velocity of four motors to 100 PERCENT.\n    \"\"\"\n    motor_left_front.set_velocity(100, PERCENT)\n    motor_right_front.set_velocity(100, PERCENT)\n    motor_left_back.set_velocity(100, PERCENT)\n    motor_right_back.set_velocity(100, PERCENT)\n\n    \"\"\"\n    Set the maximum torque of four motors to 100 PERCENT.\n    The intake wheels always spin.\n    \"\"\"\n    motor_left_front.set_max_torque(100, PERCENT)\n    motor_right_front.set_max_torque(100, PERCENT)\n    motor_left_back.set_max_torque(100, PERCENT)\n    motor_right_back.set_max_torque(100, PERCENT)\n    intake.spin(FORWARD, 100, PERCENT)\n\n    # left motor in REVERSE direction\n    # right motor in FORWARD direction\n\n    # when the robot starts in the left corner\n    while True:\n        # release the intake to the horizon\n        arm_left.spin(FORWARD)\n        arm_right.spin(REVERSE)\n        wait(1, SECONDS)\n        arm_left.stop(HOLD)\n        arm_right.stop(HOLD)\n\n        # lift the intake arm first\n        arm_left.spin_for(REVERSE, 30, DEGREES)\n        arm_right.spin_for(FORWARD, 30, DEGREES)\n\n        # turn right\n        motor_left_front.spin(REVERSE)\n        motor_left_back.spin(REVERSE)\n        motor_right_front.spin(FORWARD)\n        motor_right_back.spin(FORWARD)\n        wait(1, SECONDS)\n        motor_left_front.stop()\n        motor_left_back.stop()\n        motor_right_front.stop()\n        motor_right_back.stop()\n\n    # 插片程序\n\n\ndef initialize_driver_control():\n    # start the driver control tasks\n    _driver_thread = Thread(driver_control)\n\n    # wait for the driver control period to end\n    while (competition.is_driver_control() and competition.is_enabled()):\n        # wait 10 milliseconds before checking again\n        wait(10, MSEC)\n\n    # stop the driver control tasks\n    _driver_thread.stop()\n\n\ndef driver_control():\n    intake.spin(FORWARD, 100, PERCENT)\n    # place drive control code here, inside the loop\n    while True:\n        # This is the main loop for the driver control.\n        # Each time through the loop you should update motor\n        # movements based on input from the controller.\n\n        \"\"\"\n        Temperature return:\n        Every movement will return the temperature of the motor on the brain screen.\n        \"\"\"\n        tempArmL = arm_left.temperature()\n        tempArmR = arm_right.temperature()\n        brain.screen.clear_screen()\n        brain.screen.print(tempArmL)\n        brain.screen.print(tempArmR)\n\n        \"\"\"\n        Controller Axis 1 and Axis 3:\n        The left front motor and left back motor spin forward when pushing the left joystick forward.\n        Then, the left front motor and left back motor spin backward when pushing the left joystick backward.\n        \"\"\"\n        motor_left_front.spin(REVERSE, controller.axis1.value() + controller.axis3.value(), PERCENT)\n        motor_left_back.spin(REVERSE, controller.axis1.value() + controller.axis3.value(), PERCENT)\n        motor_right_front.spin(REVERSE, controller.axis1.value() - controller.axis3.value(), PERCENT)\n        motor_right_back.spin(REVERSE, controller.axis1.value() - controller.axis3.value(), PERCENT)\n\n        \"\"\"\n        R1 and R2 buttons:\n        The right arm motor and left arm motor lift up the arms at once when pressing the R1 button.\n        Then, the right arm motor and left arm motor lift down the arms at once when pressing the R2 button.\n        \"\"\"\n\n        if controller.buttonL1.pressing():\n            arm_left.spin_for(REVERSE, 100, PERCENT)\n            arm_right.spin_for(FORWARD, 100, PERCENT)\n            wait(0.5, SECONDS)\n\n        if controller.buttonL2.pressing():\n            arm_left.spin_for(FORWARD, 100, PERCENT)\n            arm_right.spin_for(REVERSE, 100, PERCENT)\n            wait(0.5, SECONDS)\n\n        if controller.buttonR1.pressing():\n            intake.spin(REVERSE, 100, PERCENT)\n\n        if controller.buttonR2.pressing():\n            intake.spin(FORWARD, 100, PERCENT)\n\n        if controller.buttonUp.pressing():\n            launcher.spin(FORWARD, 100, PERCENT)\n\n        if controller.buttonDown.pressing():\n            launcher.set_position(0, DEGREES)\n            launcher.stop(HOLD)\n        else:\n            # Stop the arms only if neither ButtonL2 nor ButtonL1 is pressed\n            arm_left.stop(HOLD)\n            arm_right.stop(HOLD)\n            wait(20, MSEC)\n\n\n# allows access to Competition methods\ncompetition = Competition(driver_control, autonomous)\n","textLanguage":"python","rconfig":[{"port":[1],"name":"motor_1","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"正","rev":"反","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"motor_2","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"正","rev":"反","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"motor_1","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"}}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"","minVersion":"3.0.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}